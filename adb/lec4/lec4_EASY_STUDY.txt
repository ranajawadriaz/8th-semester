================================================================================
    üéØ LECTURE 4 - EASY STUDY GUIDE (ADHD-FRIENDLY) üéØ
    CONCURRENCY CONTROL TECHNIQUES - LOCKING & TIMESTAMPS
================================================================================

Hey! This is YOUR exam-ready guide. Everything is explained simply.
Read section by section. Take breaks between ‚≠ê symbols if needed!

================================================================================
üìö PART 1: WHAT IS CONCURRENCY CONTROL?
================================================================================

üîµ THE GOAL:
------------
‚Ä¢ Prevent problems when multiple transactions access SAME data
‚Ä¢ Ensure SERIALIZABILITY (results equal to some serial execution)
‚Ä¢ Maintain database CONSISTENCY

üîµ THREE WAYS TO HANDLE CONFLICTS:
----------------------------------
1. ALLOW the schedule (if order is correct)
2. BLOCK/WAIT (put transaction in waiting queue)
3. ABORT/ROLLBACK (kill the transaction, restart later)

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 2: LOCKING BASICS (Foundation!)
================================================================================

üîµ WHAT IS A LOCK?
------------------
‚Ä¢ A LOCK is like a "reservation" on a data item
‚Ä¢ Before you can read or write data, you must GET A LOCK
‚Ä¢ It's like raising your hand before speaking in class!

üîµ BASIC RULES OF LOCKING:
--------------------------
1. You MUST lock a data item BEFORE reading or writing it
2. You CANNOT lock an item that's already locked (by others)
3. You CANNOT unlock an item that's not locked
4. Lock and Unlock are ATOMIC operations (instant, can't be interrupted)

üîµ LOCK TABLE:
--------------
‚Ä¢ The system maintains a TABLE that tracks:
  - Which data item is locked
  - Which transaction has the lock
  - What type of lock (shared/exclusive)
  
Example Lock Table:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Data Item  ‚îÇ Transaction ‚îÇ Lock Type ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ X          ‚îÇ T1          ‚îÇ Shared    ‚îÇ
‚îÇ X          ‚îÇ T2          ‚îÇ Shared    ‚îÇ
‚îÇ Y          ‚îÇ T3          ‚îÇ Exclusive ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 3: TYPES OF LOCKS (Very Important!)
================================================================================

üîµ TWO MAIN LOCK TYPES:
-----------------------

1. SHARED LOCK (S-Lock / Read Lock)
   ‚Ä¢ Used for READING data
   ‚Ä¢ MULTIPLE transactions can have shared locks on SAME item
   ‚Ä¢ Think: "Many people can READ a library book at once"
   
2. EXCLUSIVE LOCK (X-Lock / Write Lock)
   ‚Ä¢ Used for WRITING data
   ‚Ä¢ ONLY ONE transaction can have exclusive lock
   ‚Ä¢ No other locks (shared or exclusive) allowed
   ‚Ä¢ Think: "Only ONE person can EDIT a document at a time"

üîµ COMPATIBILITY MATRIX:
------------------------

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë Request ‚Üí         ‚ïë Shared (S)    ‚ïë Exclusive (X) ‚ïë
‚ïë Current ‚Üì         ‚ïë               ‚ïë               ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë No Lock           ‚ïë ‚úÖ GRANT       ‚ïë ‚úÖ GRANT       ‚ïë
‚ïë Shared (S)        ‚ïë ‚úÖ GRANT       ‚ïë ‚ùå WAIT        ‚ïë
‚ïë Exclusive (X)     ‚ïë ‚ùå WAIT        ‚ïë ‚ùå WAIT        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

MEMORY TRICK: 
‚Ä¢ "Shared-Shared = OK" (Many can read)
‚Ä¢ "Anything with Exclusive = NOT OK" (Writer needs privacy)

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 4: READ COUNT MECHANISM
================================================================================

üîµ HOW SHARED LOCKS WORK:
-------------------------
‚Ä¢ System tracks NUMBER OF READERS with a counter
‚Ä¢ read_count(X) = How many transactions are reading X

PROCESS:
1. T1 wants to read X (no lock exists)
   ‚Üí Lock X in shared mode
   ‚Üí read_count(X) = 1 ‚úì

2. T2 wants to read X (shared lock exists)
   ‚Üí No new lock needed, just increment counter
   ‚Üí read_count(X) = 2 ‚úì

3. T1 finishes reading, releases lock
   ‚Üí read_count(X) = 2 - 1 = 1
   ‚Üí Lock NOT released yet (T2 still reading)

4. T2 finishes reading, releases lock
   ‚Üí read_count(X) = 1 - 1 = 0
   ‚Üí read_count = 0 ‚Üí UNLOCK X!

üîµ KEY INSIGHT:
---------------
‚Ä¢ Unlock only happens when read_count reaches ZERO
‚Ä¢ Last reader to leave turns off the lights!

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 5: LOCK UPGRADE AND DOWNGRADE
================================================================================

üîµ LOCK UPGRADE (Shared ‚Üí Exclusive):
------------------------------------
‚Ä¢ Transaction has a SHARED lock and wants to WRITE
‚Ä¢ Needs to UPGRADE to EXCLUSIVE lock

CONDITIONS FOR UPGRADE:
‚Ä¢ The requesting transaction must be THE ONLY reader
‚Ä¢ read_count must be 1 (only itself)
‚Ä¢ If others are also reading ‚Üí MUST WAIT

Example:
‚Ä¢ T1 has shared lock on X (read_count = 1)
‚Ä¢ T1 wants to write X
‚Ä¢ No other readers ‚Üí UPGRADE ALLOWED ‚úÖ

Example 2:
‚Ä¢ T1 and T2 both have shared locks on X (read_count = 2)
‚Ä¢ T1 wants to write X
‚Ä¢ T2 is still reading ‚Üí UPGRADE NOT ALLOWED, T1 WAITS ‚è≥

üîµ LOCK DOWNGRADE (Exclusive ‚Üí Shared):
--------------------------------------
‚Ä¢ Transaction has an EXCLUSIVE lock but only wants to READ now
‚Ä¢ Can downgrade to SHARED lock
‚Ä¢ ALWAYS possible (no one else has any lock!)
‚Ä¢ Why do this? To allow others to read!

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 6: TWO-PHASE LOCKING (2PL) - MOST IMPORTANT!
================================================================================

üîµ WHAT IS 2PL?
---------------
The MOST POPULAR concurrency control protocol!
Every transaction has TWO distinct phases:

PHASE 1: GROWING PHASE (Locking Phase)
‚Ä¢ Transaction can ACQUIRE new locks
‚Ä¢ Transaction CANNOT release any lock
‚Ä¢ Like collecting all the tools you need

PHASE 2: SHRINKING PHASE (Unlocking Phase)  
‚Ä¢ Transaction can RELEASE locks
‚Ä¢ Transaction CANNOT acquire new locks
‚Ä¢ Like returning tools after you're done

üîµ THE GOLDEN RULE:
-------------------
"Once you release ONE lock, you can NEVER acquire any NEW lock"

    Growing      ‚îÇ     Shrinking
    Phase        ‚îÇ     Phase
                 ‚îÇ
   ACQUIRE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ RELEASE
   ACQUIRE       ‚îÇ     RELEASE
   ACQUIRE       ‚îÇ     RELEASE
                 ‚îÇ
         ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫
              (Boundary)

üîµ WHY DOES 2PL GUARANTEE SERIALIZABILITY?
------------------------------------------
‚Ä¢ If you hold all your locks before releasing any...
‚Ä¢ No other transaction can interfere in the middle
‚Ä¢ This ensures serializable execution!

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 7: VARIANTS OF TWO-PHASE LOCKING
================================================================================

üîµ 1. BASIC 2PL:
----------------
‚Ä¢ Follows the two phases: Growing ‚Üí Shrinking
‚Ä¢ Releases locks during shrinking phase (before commit)
‚Ä¢ CAN cause cascading rollback (dirty reads possible!)
‚Ä¢ CAN cause deadlock

üîµ 2. CONSERVATIVE 2PL (Static 2PL):
------------------------------------
‚Ä¢ Lock ALL required data items BEFORE starting!
‚Ä¢ If you can't get all locks ‚Üí DON'T START
‚Ä¢ PREVENTS DEADLOCK ‚úÖ
‚Ä¢ But: Must know all items in advance (not always possible)

Example:
T1 needs X, Y, Z
‚Üí Lock X ‚úì
‚Üí Lock Y ‚úì  
‚Üí Lock Z ‚úì
‚Üí NOW start the transaction

üîµ 3. STRICT 2PL (Most Common!):
--------------------------------
‚Ä¢ Hold all WRITE locks until COMMIT or ABORT
‚Ä¢ Only release write locks AFTER transaction ends
‚Ä¢ May release read locks earlier
‚Ä¢ PREVENTS cascading rollback ‚úÖ
‚Ä¢ This is what MOST databases use!

üîµ 4. RIGOROUS 2PL:
-------------------
‚Ä¢ Hold ALL locks (both read and write) until COMMIT or ABORT
‚Ä¢ Don't release ANY lock until you're completely done
‚Ä¢ Most restrictive but SAFEST
‚Ä¢ PREVENTS cascading rollback ‚úÖ

üîµ COMPARISON TABLE:
--------------------
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë Protocol            ‚ïë Deadlock?    ‚ïë Cascading?    ‚ïë When Locks Release ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Basic 2PL           ‚ïë Possible     ‚ïë Possible      ‚ïë During execution   ‚ïë
‚ïë Conservative 2PL    ‚ïë NOT possible ‚ïë Possible      ‚ïë During execution   ‚ïë
‚ïë Strict 2PL          ‚ïë Possible     ‚ïë NOT possible  ‚ïë Write at commit    ‚ïë
‚ïë Rigorous 2PL        ‚ïë Possible     ‚ïë NOT possible  ‚ïë All at commit      ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 8: DEADLOCK IN 2PL (How It Happens)
================================================================================

üîµ EXAMPLE OF DEADLOCK IN 2PL:
------------------------------
T1 needs X and Y
T2 needs X and Y

Timeline:
1. T1 locks X ‚úì
2. T2 locks Y ‚úì
3. T1 wants Y ‚Üí WAIT (T2 has it)
4. T2 wants X ‚Üí WAIT (T1 has it)

RESULT: DEADLOCK! 
Both waiting for each other forever!

    T1 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ wants ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Y (held by T2)
     ‚Üë                          ‚îÇ
     ‚îÇ                          ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    X (held by T1) ‚Üê‚îÄ‚îÄ wants ‚îÄ‚îÄ T2

üîµ UPGRADE DEADLOCK:
--------------------
T1 has shared lock on X
T2 has shared lock on X
T1 wants to upgrade ‚Üí WAIT for T2
T2 wants to upgrade ‚Üí WAIT for T1
DEADLOCK!

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 9: HANDLING DEADLOCKS
================================================================================

üîµ METHOD 1: DEADLOCK DETECTION
-------------------------------
Let deadlock happen, then fix it!

HOW:
1. Build a WAIT-FOR GRAPH
   ‚Ä¢ Node for each transaction
   ‚Ä¢ Edge: Ti ‚Üí Tj means Ti is waiting for Tj
   
2. Check for CYCLES periodically
   ‚Ä¢ Cycle = DEADLOCK!
   
3. If deadlock found:
   ‚Ä¢ Pick a VICTIM transaction
   ‚Ä¢ ABORT the victim
   ‚Ä¢ Other transactions continue

üîµ METHOD 2: DEADLOCK AVOIDANCE (Wait-Die & Wound-Wait)
------------------------------------------------------
Use TIMESTAMPS to avoid deadlock!

TIMESTAMP BASICS:
‚Ä¢ Each transaction has a timestamp (when it started)
‚Ä¢ Smaller timestamp = OLDER transaction (started earlier)
‚Ä¢ Larger timestamp = YOUNGER transaction (started later)

Example:
‚Ä¢ T1 timestamp = 100 (started at time 100)
‚Ä¢ T2 timestamp = 150 (started at time 150)
‚Ä¢ T1 is OLDER, T2 is YOUNGER

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

üîµ WAIT-DIE SCHEME:
-------------------
"Older WAITS, Younger DIES"

If Ti wants a resource held by Tj:
‚Ä¢ If Ti is OLDER than Tj ‚Üí Ti WAITS (patient old person)
‚Ä¢ If Ti is YOUNGER than Tj ‚Üí Ti DIES (abort) and restarts later

Example:
‚Ä¢ T1 (older) wants resource held by T2 (younger) ‚Üí T1 WAITS
‚Ä¢ T2 (younger) wants resource held by T1 (older) ‚Üí T2 DIES

WHY NO DEADLOCK?
‚Ä¢ Older transactions never abort, only wait
‚Ä¢ Younger transactions abort and restart
‚Ä¢ Cycle cannot form!

üîµ WOUND-WAIT SCHEME:
---------------------
"Older WOUNDS (kills), Younger WAITS"

If Ti wants a resource held by Tj:
‚Ä¢ If Ti is OLDER than Tj ‚Üí Ti WOUNDS Tj (aborts Tj) and takes resource
‚Ä¢ If Ti is YOUNGER than Tj ‚Üí Ti WAITS

Example:
‚Ä¢ T1 (older) wants resource held by T2 (younger) ‚Üí T1 WOUNDS T2, T2 aborts
‚Ä¢ T2 (younger) wants resource held by T1 (older) ‚Üí T2 WAITS

WHY NO DEADLOCK?
‚Ä¢ Older transactions are aggressive, push younger out
‚Ä¢ Younger transactions are patient, always wait
‚Ä¢ Cycle cannot form!

üîµ COMPARISON:
--------------
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë Scheme         ‚ïë Behavior                                  ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë WAIT-DIE       ‚ïë Older waits, Younger dies (aborts)       ‚ïë
‚ïë WOUND-WAIT     ‚ïë Older wounds (kills younger), Younger waits‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

MEMORY TRICK:
‚Ä¢ Wait-DIE: Younger DIEs
‚Ä¢ Wound-WAIT: Younger WAITs

üîµ METHOD 3: DEADLOCK PREVENTION
--------------------------------
‚Ä¢ Lock ALL resources at START (Conservative 2PL)
‚Ä¢ If can't get all ‚Üí Don't start
‚Ä¢ No waiting ‚Üí No deadlock!
‚Ä¢ But: Poor throughput

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 10: TIMESTAMP ORDERING PROTOCOL (Alternative to Locking)
================================================================================

üîµ BASIC IDEA:
--------------
‚Ä¢ Don't use locks at all!
‚Ä¢ Use timestamps to order operations
‚Ä¢ Older transactions should be processed first

üîµ TIMESTAMP VARIABLES:
-----------------------
For each data item X:
‚Ä¢ read_TS(X) = Timestamp of LAST transaction that READ X
‚Ä¢ write_TS(X) = Timestamp of LAST transaction that WROTE X

üîµ BASIC TIMESTAMP ORDERING RULES:
----------------------------------

RULE 1: Transaction T wants to READ X
‚Ä¢ If write_TS(X) > TS(T):
  ‚Üí A YOUNGER transaction already wrote X
  ‚Üí T is trying to read an OLD value
  ‚Üí ABORT T! (Too late!)
  
‚Ä¢ Else: Allow the read
  ‚Üí Update read_TS(X) = max(read_TS(X), TS(T))

RULE 2: Transaction T wants to WRITE X
‚Ä¢ If read_TS(X) > TS(T):
  ‚Üí A YOUNGER transaction already read X
  ‚Üí T would overwrite value they needed
  ‚Üí ABORT T!
  
‚Ä¢ If write_TS(X) > TS(T):
  ‚Üí A YOUNGER transaction already wrote X
  ‚Üí T's write is outdated
  ‚Üí ABORT T!
  
‚Ä¢ Else: Allow the write
  ‚Üí Update write_TS(X) = TS(T)

üîµ EXAMPLE:
-----------
Assume TS(T1) = 10, TS(T2) = 20

Item X: read_TS(X) = 0, write_TS(X) = 0

1. T1 wants to read X:
   ‚Ä¢ write_TS(X) = 0, TS(T1) = 10
   ‚Ä¢ 0 > 10? NO ‚Üí ALLOW
   ‚Ä¢ read_TS(X) = max(0, 10) = 10

2. T2 wants to write X:
   ‚Ä¢ read_TS(X) = 10, TS(T2) = 20
   ‚Ä¢ 10 > 20? NO ‚Üí Continue
   ‚Ä¢ write_TS(X) = 0, TS(T2) = 20
   ‚Ä¢ 0 > 20? NO ‚Üí ALLOW
   ‚Ä¢ write_TS(X) = 20

3. T1 wants to write X:
   ‚Ä¢ read_TS(X) = 10, TS(T1) = 10
   ‚Ä¢ 10 > 10? NO ‚Üí Continue  
   ‚Ä¢ write_TS(X) = 20, TS(T1) = 10
   ‚Ä¢ 20 > 10? YES ‚Üí ABORT T1! ‚ùå

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 11: THOMAS'S WRITE RULE
================================================================================

üîµ THE PROBLEM WITH BASIC TO:
-----------------------------
If T1 (older) tries to write X after T2 (younger) already wrote X...
Basic TO would abort T1.

But wait! T1's write doesn't matter anyway!
T2's write is more recent!

üîµ THOMAS'S WRITE RULE:
-----------------------
If write_TS(X) > TS(T):
‚Ä¢ DON'T abort T!
‚Ä¢ Just IGNORE T's write (skip it)
‚Ä¢ Continue with T's other operations

WHY? 
‚Ä¢ T2's write is the "official" value
‚Ä¢ T1's write would be immediately overwritten anyway
‚Ä¢ So just skip it!

This REDUCES unnecessary aborts!

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 12: MULTIVERSION CONCURRENCY CONTROL (MVCC)
================================================================================

üîµ THE IDEA:
------------
‚Ä¢ Keep MULTIPLE VERSIONS of each data item
‚Ä¢ Different transactions can see different versions
‚Ä¢ Readers NEVER blocked (always find a version to read!)

üîµ HOW IT WORKS:
----------------
Item X has versions: X0, X1, X2, X3...

Each version Xi has:
‚Ä¢ write_TS(Xi) = Timestamp of transaction that created this version
‚Ä¢ read_TS(Xi) = Largest timestamp of transaction that read this version

When T wants to read X:
‚Ä¢ Find version with LARGEST write_TS ‚â§ TS(T)
‚Ä¢ Read NEVER rejected!

When T wants to write X:
‚Ä¢ May need to create a new version
‚Ä¢ Some restrictions apply (see rules in slides)

üîµ BENEFIT:
-----------
‚Ä¢ READ operations are NEVER blocked or aborted!
‚Ä¢ Great for read-heavy workloads

üîµ COST:
--------
‚Ä¢ More STORAGE needed (multiple versions)
‚Ä¢ Need garbage collection to remove old versions

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 13: OPTIMISTIC CONCURRENCY CONTROL (OCC)
================================================================================

üîµ THE PHILOSOPHY:
------------------
"Just do it! Worry about conflicts later."

Assume conflicts are RARE.
‚Ä¢ Let transactions execute without locking
‚Ä¢ Check for conflicts at the END
‚Ä¢ If conflict ‚Üí abort and restart

üîµ THREE PHASES:
----------------

PHASE 1: READ PHASE (Working Phase)
‚Ä¢ Transaction reads data items
‚Ä¢ Makes changes in PRIVATE workspace
‚Ä¢ Database NOT modified yet!
‚Ä¢ Tracks READ SET and WRITE SET

PHASE 2: VALIDATION PHASE
‚Ä¢ When transaction wants to commit...
‚Ä¢ Check: Did this conflict with any other transaction?
‚Ä¢ If YES ‚Üí ABORT
‚Ä¢ If NO ‚Üí Proceed to write phase

PHASE 3: WRITE PHASE
‚Ä¢ Only reached if validation passed
‚Ä¢ Write all changes to database
‚Ä¢ Commit!

üîµ VALIDATION TYPES:
--------------------

BACKWARD VALIDATION:
‚Ä¢ Compare with transactions that ALREADY committed
‚Ä¢ Check: Did I read anything they wrote?

FORWARD VALIDATION:
‚Ä¢ Compare with transactions that are STILL active
‚Ä¢ Check: Did I write anything they're reading?

üîµ WHEN IS OCC GOOD?
--------------------
‚Ä¢ When conflicts are RARE
‚Ä¢ Read-heavy workloads
‚Ä¢ Short transactions

üîµ WHEN IS OCC BAD?
-------------------
‚Ä¢ When conflicts are FREQUENT
‚Ä¢ A lot of wasted work if validation fails
‚Ä¢ May cause starvation (same transaction keeps aborting)

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 14: GRANULARITY (Lock Size)
================================================================================

üîµ WHAT IS GRANULARITY?
-----------------------
The "size" of what you're locking:

FINE GRANULARITY (Small):
‚Ä¢ Lock a single RECORD or ATTRIBUTE
‚Ä¢ More concurrency (different transactions can access different records)
‚Ä¢ More overhead (many locks to manage)

COARSE GRANULARITY (Large):
‚Ä¢ Lock entire TABLE or DATABASE
‚Ä¢ Less concurrency (one lock blocks many transactions)
‚Ä¢ Less overhead (fewer locks to manage)

üîµ GRANULARITY HIERARCHY:
-------------------------
Database (Largest)
    ‚îî‚îÄ‚îÄ File/Table
         ‚îî‚îÄ‚îÄ Page/Block
              ‚îî‚îÄ‚îÄ Record/Row
                   ‚îî‚îÄ‚îÄ Field/Attribute (Smallest)

üîµ INTENTION LOCKS:
-------------------
When using hierarchical locking, use INTENTION LOCKS:

IS (Intention Shared):
‚Ä¢ "I intend to get shared locks on items below"

IX (Intention Exclusive):
‚Ä¢ "I intend to get exclusive locks on items below"

SIX (Shared + Intention Exclusive):
‚Ä¢ "I have shared lock here, but will get exclusive locks below"

üîµ RULES FOR MULTIPLE GRANULARITY:
----------------------------------
1. Lock the ROOT (database) first
2. Before locking a node in S or IS mode ‚Üí Parent must be IS or IX
3. Before locking a node in X, IX, or SIX ‚Üí Parent must be IX or SIX
4. Follow 2PL (no unlock before all locks acquired)
5. Unlock in REVERSE order (children before parents)

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

================================================================================
üìö PART 15: PRACTICE PROBLEM SOLUTIONS (From Slides)
================================================================================

üîµ PROBLEM TYPE: Apply Different Protocols to Same Schedule
-----------------------------------------------------------

Schedule S: r1(X), w2(X), w2(Y), w3(Y), w1(Y), c1, c2, c3

FOR EACH PROTOCOL, ASK:
1. Which operations are allowed?
2. Which transactions wait/abort?
3. What's the final result?

RIGOROUS 2PL (Wait-Die):
‚Ä¢ T1 gets shared lock on X
‚Ä¢ T2 wants exclusive lock on X ‚Üí T2 is younger ‚Üí T2 ABORTS (dies)
‚Ä¢ T3 gets exclusive lock on Y
‚Ä¢ T1 wants exclusive lock on Y ‚Üí T1 is older ‚Üí T1 WAITS for T3
‚Ä¢ T3 commits, releases Y
‚Ä¢ T1 gets Y, writes, commits
‚Ä¢ T2 can restart

RIGOROUS 2PL (Wound-Wait):
‚Ä¢ T1 gets shared lock on X
‚Ä¢ T2 wants exclusive lock on X ‚Üí T2 is younger ‚Üí T2 WAITS
‚Ä¢ T3 gets exclusive lock on Y
‚Ä¢ T1 wants exclusive lock on Y ‚Üí T1 is older ‚Üí T1 WOUNDS T3
‚Ä¢ T3 aborts, releases Y
‚Ä¢ T1 gets Y, writes, commits
‚Ä¢ T2 wakes up, completes, commits
‚Ä¢ T3 can restart

BASIC TIMESTAMP ORDERING:
‚Ä¢ Use read_TS and write_TS
‚Ä¢ Check each operation against timestamp rules
‚Ä¢ Abort if out of order

================================================================================
üéØ EXAM TIPS FOR LECTURE 4
================================================================================

1. KNOW THE LOCK COMPATIBILITY MATRIX:
   ‚Ä¢ S + S = OK
   ‚Ä¢ S + X = NO
   ‚Ä¢ X + X = NO

2. UNDERSTAND TWO-PHASE LOCKING:
   ‚Ä¢ Growing phase: Acquire locks
   ‚Ä¢ Shrinking phase: Release locks
   ‚Ä¢ Once you release one, you can't get any new ones!

3. KNOW THE 2PL VARIANTS:
   ‚Ä¢ Basic: Releases during execution
   ‚Ä¢ Conservative: All locks at start
   ‚Ä¢ Strict: Write locks until commit
   ‚Ä¢ Rigorous: All locks until commit

4. WAIT-DIE vs WOUND-WAIT:
   ‚Ä¢ Wait-Die: Older waits, Younger dies
   ‚Ä¢ Wound-Wait: Older wounds, Younger waits

5. TIMESTAMP ORDERING:
   ‚Ä¢ Read: Check write_TS
   ‚Ä¢ Write: Check both read_TS and write_TS
   ‚Ä¢ Younger timestamp already there? ‚Üí ABORT!

6. KNOW HOW TO SOLVE PROBLEMS:
   ‚Ä¢ Add lock/unlock operations to schedule
   ‚Ä¢ Identify conflicts
   ‚Ä¢ Apply deadlock handling
   ‚Ä¢ Determine final result

================================================================================
‚úÖ QUICK MEMORY TRICKS
================================================================================

"SHARED = READING = MANY ALLOWED"
"EXCLUSIVE = WRITING = ONLY ONE"

"2PL = GET FIRST, RELEASE LATER, NEVER BOTH"

"WAIT-DIE = YOUNGER DIES"
"WOUND-WAIT = YOUNGER WAITS"

"OLDER = SMALLER TIMESTAMP"
"YOUNGER = LARGER TIMESTAMP"

"CONSERVATIVE = ALL LOCKS AT START = NO DEADLOCK"
"STRICT = WRITE LOCKS UNTIL COMMIT = NO CASCADE"

"OCC = DO FIRST, CHECK LATER"

================================================================================
                    üí™ YOU GOT THIS! GOOD LUCK! üí™
================================================================================

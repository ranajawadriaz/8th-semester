================================================================================
    ğŸ¯ LECTURE 3 - EASY STUDY GUIDE (ADHD-FRIENDLY) ğŸ¯
    DATABASE RECOVERY TECHNIQUES & TRANSACTION STATES
================================================================================

Hey! This is YOUR exam-ready guide. Everything is explained simply.
Read section by section. Take breaks between â­ symbols if needed!

================================================================================
ğŸ“š PART 1: WHY DO WE NEED RECOVERY?
================================================================================

ğŸ”µ THE PROBLEM:
---------------
Computers can CRASH at any time!
â€¢ Power failure
â€¢ Hardware failure
â€¢ Software bugs
â€¢ Disk failure

When a crash happens:
â€¢ Some transactions were RUNNING (active)
â€¢ Some transactions were COMMITTED but not written to disk
â€¢ Data in memory (RAM) is LOST!

ğŸ”µ THE GOAL:
------------
After a crash, the database must be RECOVERED to a CONSISTENT state:
â€¢ All COMMITTED transactions â†’ Their effects must be SAVED
â€¢ All ACTIVE (incomplete) transactions â†’ Their effects must be UNDONE

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 2: DATABASE BUFFER CACHE (Memory Management)
================================================================================

ğŸ”µ WHAT IS THE BUFFER CACHE?
----------------------------
â€¢ A part of RAM (memory) where data is temporarily stored
â€¢ Data is read from DISK â†’ stored in BUFFER â†’ processed
â€¢ Changes are made in BUFFER first, then written to DISK later

WHY USE A BUFFER?
â€¢ Disk is SLOW, Memory is FAST
â€¢ Keep frequently used data in memory
â€¢ Better performance!

ğŸ”µ THE TWO FILES ON DISK:
-------------------------

1. DATABASE FILE
   â€¢ Contains the ACTUAL DATA (tables, records)
   â€¢ When we update X from 10 to 20, the file stores 20
   â€¢ OLD value (10) is REPLACED with new value (20)

2. LOG FILE
   â€¢ Contains the HISTORY of all changes
   â€¢ Stores BOTH old and new values
   â€¢ X: Before = 10, After = 20
   â€¢ Used for RECOVERY!

ğŸ”µ THE TWO CACHES IN MEMORY:
----------------------------

1. DATABASE BUFFER CACHE
   â€¢ Holds copies of data blocks from the database file
   â€¢ Changes are made here first

2. LOG BUFFER CACHE
   â€¢ Holds log entries before they're written to log file
   â€¢ When full, written to log file on disk

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 3: CACHE HIT RATIO (Performance Concept)
================================================================================

ğŸ”µ WHAT IS CACHE HIT?
---------------------
â€¢ CACHE HIT: Data is found in memory â†’ FAST! No disk read needed
â€¢ CACHE MISS: Data not in memory â†’ SLOW! Must read from disk

ğŸ”µ CACHE HIT RATIO:
-------------------
    Cache Hit Ratio = (Hits / Total Requests) Ã— 100

Higher ratio = Better performance!

Example:
â€¢ 90 requests found in cache (hits)
â€¢ 10 requests needed disk read (misses)
â€¢ Hit ratio = 90/100 = 90% â†’ GOOD!

ğŸ”µ HOW TO IMPROVE CACHE HIT RATIO?
----------------------------------

1. DELAY WRITING to disk
   â€¢ Keep modified data in cache longer
   â€¢ Other transactions can read from cache
   â€¢ RISK: If crash happens, cache data is lost!

2. USE SMART ALGORITHMS:
   â€¢ HOTSPOT Method: Keep frequently accessed blocks in cache
   â€¢ PREFETCHING: Load data BEFORE it's requested
   â€¢ LRU (Least Recently Used): Remove blocks that haven't been used recently

ğŸ”µ TRADE-OFF:
-------------
â€¢ Keep data in cache LONGER â†’ Better performance BUT more risk
â€¢ Write to disk SOONER â†’ Safer BUT slower

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 4: CHECKPOINT (SUPER IMPORTANT!)
================================================================================

ğŸ”µ WHAT IS A CHECKPOINT?
------------------------
A CHECKPOINT is a point in time when:
â€¢ All modified data in the buffer cache is written to disk
â€¢ A checkpoint record is written to the log file
â€¢ Database and log are SYNCHRONIZED

Think of it like:
â€¢ SAVING your game in a video game
â€¢ If you die (crash), you restart from the last save point!

ğŸ”µ WHEN DOES CHECKPOINT HAPPEN?
-------------------------------
â€¢ After N transactions complete (e.g., every 10 transactions)
â€¢ After T time passes (e.g., every 5 seconds)
â€¢ Whichever condition is met FIRST

ğŸ”µ WHAT HAPPENS AT CHECKPOINT?
------------------------------
1. STOP accepting new transactions temporarily
2. WRITE all modified pages from buffer to database file
3. WRITE a checkpoint record to log file
4. RESUME normal operations

ğŸ”µ WHY IS CHECKPOINT IMPORTANT?
-------------------------------
â€¢ Recovery only needs to look at transactions AFTER the last checkpoint
â€¢ Transactions BEFORE checkpoint are already safely on disk
â€¢ FASTER recovery!

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 5: THE LOG FILE (Transaction History)
================================================================================

ğŸ”µ WHAT IS STORED IN THE LOG?
-----------------------------
For each operation, the log stores:
â€¢ Transaction ID (which transaction)
â€¢ Operation type (BEGIN, READ, WRITE, COMMIT, ABORT)
â€¢ Data item (which item X, Y, etc.)
â€¢ BEFORE IMAGE (old value)
â€¢ AFTER IMAGE (new value)

Example Log Entries:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [T1, BEGIN]                                              â”‚
â”‚ [T1, WRITE, X, before=10, after=20]                     â”‚
â”‚ [T1, WRITE, Y, before=50, after=100]                    â”‚
â”‚ [T1, COMMIT]                                             â”‚
â”‚ [T2, BEGIN]                                              â”‚
â”‚ [T2, WRITE, X, before=20, after=30]                     â”‚
â”‚ [CHECKPOINT]                                             â”‚
â”‚ [T3, BEGIN]                                              â”‚
â”‚ ... CRASH HAPPENS HERE ...                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”µ WHY STORE BOTH VALUES?
-------------------------
â€¢ BEFORE IMAGE: Needed for UNDO (if transaction fails)
â€¢ AFTER IMAGE: Needed for REDO (if transaction committed but not written)

ğŸ”µ LOG IS SEQUENTIAL:
---------------------
â€¢ New entries are APPENDED at the end
â€¢ Log is written in ORDER of operations
â€¢ Each entry points to the next entry of same transaction

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 6: WRITE-AHEAD LOGGING (WAL) PROTOCOL
================================================================================

ğŸ”µ THE RULE:
------------
BEFORE writing any change to the DATABASE file,
you MUST FIRST write it to the LOG file!

    LOG FIRST â†’ THEN DATABASE

ğŸ”µ WHY THIS ORDER?
------------------
â€¢ If crash happens AFTER writing to database but BEFORE writing to log...
â€¢ We won't know what was changed!
â€¢ We can't recover!

With WAL:
â€¢ If crash after log write but before database write â†’ We can REDO
â€¢ If crash before log write â†’ Data wasn't written to database either â†’ Safe!

ğŸ”µ SIMPLE RULE:
---------------
"Write to LOG, then write to DATABASE"
"NEVER write to database without logging first!"

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 7: COMMIT POINT (Transaction Guarantee)
================================================================================

ğŸ”µ WHAT IS A COMMIT POINT?
--------------------------
The moment when a transaction is GUARANTEED to be permanent!

Before commit point â†’ Transaction can still fail/abort
After commit point â†’ Transaction is PERMANENT, cannot be undone

ğŸ”µ WHEN DOES COMMIT POINT HAPPEN?
---------------------------------
A transaction reaches its COMMIT POINT when:
1. ALL its operations have completed successfully
2. ALL its log entries have been written to the LOG FILE (not just buffer!)
3. The COMMIT record is written to the log file

ONLY THEN does the system respond "COMMIT SUCCESSFUL"

ğŸ”µ EXAMPLE:
-----------
T1 does: Read X, Write X, Read Y, Write Y

Commit Point happens:
1. All 4 operations completed âœ“
2. Log entries for all 4 operations written to LOG FILE on disk âœ“
3. [T1, COMMIT] written to LOG FILE on disk âœ“
4. System says: "COMMIT SUCCESSFUL!"

Now even if system crashes:
â€¢ T1's commit record is in the log
â€¢ Recovery will REDO T1's operations
â€¢ T1's changes are GUARANTEED!

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 8: RECOVERY PROCESS (After a Crash)
================================================================================

ğŸ”µ THE SITUATION:
-----------------
System just crashed! Recovery Manager must:
1. Figure out which transactions need attention
2. REDO committed transactions (their changes must persist)
3. UNDO active transactions (their partial changes must be removed)

ğŸ”µ TWO LISTS ARE CREATED:
-------------------------

LIST 1: COMMIT LIST (transactions to REDO)
â€¢ Transactions that COMMITTED AFTER the last checkpoint
â€¢ Their changes may not be written to database yet
â€¢ Must REDO their operations to ensure they're saved

LIST 2: ACTIVE LIST (transactions to UNDO)
â€¢ Transactions that were STILL RUNNING when crash happened
â€¢ No COMMIT record for them in the log
â€¢ Must UNDO any partial changes they made

ğŸ”µ EXAMPLE SCENARIO:
--------------------
Timeline:
    T1 |â”€â”€â”€â”€â”€â”€â”€COMMITâ”€â”€â”€â”€â”€â”€|
    T2 |â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ STILL RUNNING â”€â”€â”€â”€ CRASH!
    T3            |â”€â”€â”€â”€â”€â”€â”€COMMITâ”€â”€â”€â”€â”€â”€|
    T4                     |â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ STILL RUNNING â”€â”€â”€â”€ CRASH!
    T5                          |â”€â”€â”€â”€ STILL RUNNING â”€â”€â”€â”€ CRASH!
                          ^                              ^
                     CHECKPOINT                        CRASH

ANALYSIS:
â€¢ T1: Committed BEFORE checkpoint â†’ IGNORE (already safe on disk)
â€¢ T2: Active at crash time â†’ UNDO (in Active List)
â€¢ T3: Committed AFTER checkpoint â†’ REDO (in Commit List)
â€¢ T4: Active at crash time â†’ UNDO (in Active List)
â€¢ T5: Active at crash time â†’ UNDO (in Active List)

COMMIT LIST: T3
ACTIVE LIST: T2, T4, T5

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 9: REDO AND UNDO OPERATIONS
================================================================================

ğŸ”µ REDO (Forward Recovery)
--------------------------
â€¢ For transactions in COMMIT LIST
â€¢ Read log FORWARD (from checkpoint to crash)
â€¢ Apply the AFTER IMAGE values
â€¢ Ensures committed changes are saved

Example:
Log says: [T3, WRITE, X, before=10, after=20]
REDO: Set X = 20 in database

ğŸ”µ UNDO (Backward Recovery)
---------------------------
â€¢ For transactions in ACTIVE LIST
â€¢ Read log BACKWARD (from crash to start of transaction)
â€¢ Apply the BEFORE IMAGE values
â€¢ Removes partial changes

Example:
Log says: [T2, WRITE, Y, before=50, after=100]
UNDO: Set Y = 50 in database (restore old value)

ğŸ”µ ORDER OF OPERATIONS:
-----------------------
1. First, UNDO all active transactions (go BACKWARD in log)
2. Then, REDO all committed transactions (go FORWARD in log)

This ensures database is consistent!

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 10: STEALING AND FORCING (Throughput Concepts)
================================================================================

ğŸ”µ STEALING PAGES:
------------------
WHAT: Writing UNCOMMITTED transaction's data to disk

WHY: To free up buffer space

â€¢ Transaction T1 is still running (not committed)
â€¢ But buffer is full, need space
â€¢ We WRITE T1's modified pages to disk EARLY
â€¢ This is called "STEALING"

RISK: If T1 aborts, we need to UNDO these writes from the database!

ğŸ”µ FORCING:
-----------
WHAT: Writing all modified pages to disk at COMMIT time

â€¢ Transaction commits
â€¢ FORCE all its changes to database immediately
â€¢ Don't wait for checkpoint

BENEFIT: No need to REDO during recovery
COST: Slower commits

ğŸ”µ THE TRADE-OFFS:
------------------

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ POLICY             â”‚ EXPLANATION                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ NO-STEAL           â”‚ Never write uncommitted data to disk      â”‚
â”‚                    â”‚ + No UNDO needed during recovery          â”‚
â”‚                    â”‚ - Buffer space is limited                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ STEAL              â”‚ May write uncommitted data to disk        â”‚
â”‚                    â”‚ + Better buffer utilization               â”‚
â”‚                    â”‚ - UNDO may be needed during recovery      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ FORCE              â”‚ Write to disk at commit time              â”‚
â”‚                    â”‚ + No REDO needed during recovery          â”‚
â”‚                    â”‚ - Slower commits                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ NO-FORCE           â”‚ Delay writes until checkpoint             â”‚
â”‚                    â”‚ + Faster commits                          â”‚
â”‚                    â”‚ - REDO may be needed during recovery      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

MOST COMMON: STEAL + NO-FORCE
â€¢ Best throughput
â€¢ Requires both UNDO and REDO during recovery

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 11: TRANSACTION STATES DIAGRAM (Detailed)
================================================================================

ğŸ”µ STATE DIAGRAM:
-----------------

                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚     ACTIVE      â”‚
                        â”‚  (Running ops)  â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
              All operations     â”‚
              completed          â”‚
                                 â–¼
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚   PARTIALLY     â”‚
                        â”‚   COMMITTED     â”‚
                        â”‚ (Checking...)   â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚                   â”‚                   â”‚
        Success              Failure            Conflict
             â”‚                   â”‚              (with others)
             â–¼                   â–¼                   â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
    â”‚    COMMITTED    â”‚ â”‚     FAILED      â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚   (Permanent!)  â”‚ â”‚ (Error occurred)â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                                 â”‚ Rollback
                                 â–¼
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚    ABORTED      â”‚
                        â”‚  (All undone)   â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”µ STATE EXPLANATIONS:
----------------------

1. ACTIVE
   â€¢ Transaction is executing read/write operations
   â€¢ Can move to PARTIALLY COMMITTED or FAILED

2. PARTIALLY COMMITTED
   â€¢ All operations done, waiting for final verification
   â€¢ Checking for conflicts with other transactions
   â€¢ If OK â†’ COMMITTED
   â€¢ If problem â†’ FAILED

3. COMMITTED
   â€¢ Transaction is PERMANENT
   â€¢ Cannot be rolled back (even after crash!)
   â€¢ ACID property: DURABILITY

4. FAILED
   â€¢ Something went wrong
   â€¢ Error, conflict, or system issue
   â€¢ Must be rolled back

5. ABORTED (TERMINATED)
   â€¢ All changes have been UNDONE
   â€¢ Transaction never existed (from database's view)
   â€¢ User can restart the transaction

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 12: ACID PROPERTIES & RECOVERY
================================================================================

ğŸ”µ WHICH COMPONENT HANDLES WHICH PROPERTY?
------------------------------------------

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PROPERTY           â”‚ WHO HANDLES IT                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ATOMICITY          â”‚ RECOVERY MANAGER                            â”‚
â”‚ (All or Nothing)   â”‚ Ensures either all changes saved or none    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CONSISTENCY        â”‚ CONCURRENCY CONTROL + Application           â”‚
â”‚ (Valid state)      â”‚ Ensures database rules are followed         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ISOLATION          â”‚ CONCURRENCY CONTROL                         â”‚
â”‚ (No interference)  â”‚ Ensures transactions don't interfere        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ DURABILITY         â”‚ RECOVERY MANAGER                            â”‚
â”‚ (Permanent)        â”‚ Ensures committed transactions survive crashâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

MEMORY TRICK: "Recovery handles A and D, Concurrency handles I and C"

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 13: SCHEDULE TYPES (Recap with Recovery Focus)
================================================================================

ğŸ”µ RECOVERABLE SCHEDULE:
------------------------
â€¢ A schedule where committed transactions NEVER need to be rolled back
â€¢ If T2 reads from T1, T1 must commit BEFORE T2 commits
â€¢ DBMS must only allow recoverable schedules!

ğŸ”µ CASCADELESS SCHEDULE:
------------------------
â€¢ No transaction reads DIRTY (uncommitted) data
â€¢ Avoids cascading rollback problem
â€¢ Better than just recoverable

ğŸ”µ STRICT SCHEDULE:
-------------------
â€¢ No transaction can read OR write an item until the last writer commits
â€¢ Simplest recovery: just restore the BEFORE IMAGE
â€¢ Most restrictive but safest

HIERARCHY: Strict âŠ‚ Cascadeless âŠ‚ Recoverable

================================================================================
ğŸ“š PART 14: VIEW SERIALIZABILITY
================================================================================

ğŸ”µ WHAT IS VIEW EQUIVALENCE?
----------------------------
Two schedules are VIEW EQUIVALENT if:

1. SAME INITIAL READS:
   â€¢ For every read operation, if T reads X's initial value in Schedule S,
   â€¢ T must also read X's initial value in Schedule S'

2. SAME READ-WRITE RELATIONSHIP:
   â€¢ If T1 reads a value written by T2 in S,
   â€¢ T1 must also read that value written by T2 in S'

3. SAME FINAL WRITES:
   â€¢ The last write on each item must be by the same transaction
   â€¢ In both schedules

ğŸ”µ VIEW SERIALIZABLE:
---------------------
A schedule is VIEW SERIALIZABLE if it is view equivalent to some serial schedule.

Note: View serializability is BROADER than conflict serializability.
Some schedules are view serializable but NOT conflict serializable.

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ¯ EXAM TIPS FOR LECTURE 3
================================================================================

1. UNDERSTAND the role of LOG FILE:
   â€¢ Stores BEFORE and AFTER images
   â€¢ Written BEFORE database (WAL protocol)
   â€¢ Used for REDO and UNDO

2. KNOW the COMMIT POINT:
   â€¢ All operations complete + All log entries on disk + COMMIT record
   â€¢ After this, transaction is PERMANENT

3. CHECKPOINT concept:
   â€¢ Synchronization point
   â€¢ Recovery starts from last checkpoint
   â€¢ Transactions before checkpoint are safe

4. RECOVERY PROCESS:
   â€¢ COMMIT LIST â†’ REDO (forward, use after-image)
   â€¢ ACTIVE LIST â†’ UNDO (backward, use before-image)

5. ACID properties:
   â€¢ Recovery Manager: Atomicity, Durability
   â€¢ Concurrency Control: Isolation, Consistency

================================================================================
âœ… QUICK MEMORY TRICKS
================================================================================

"WAL = Write Ahead Logging = Log FIRST, Database SECOND"

"CHECKPOINT = GAME SAVE POINT"

"COMMIT LIST = REDO = FORWARD = AFTER IMAGE"

"ACTIVE LIST = UNDO = BACKWARD = BEFORE IMAGE"

"STEAL = Write early, FORCE = Write at commit"

"COMMITTED = PERMANENT = Cannot be undone"

================================================================================
                    ğŸ’ª YOU GOT THIS! GOOD LUCK! ğŸ’ª
================================================================================

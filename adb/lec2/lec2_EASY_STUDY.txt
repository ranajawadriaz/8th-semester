================================================================================
    ğŸ¯ LECTURE 2 - EASY STUDY GUIDE (ADHD-FRIENDLY) ğŸ¯
    TRANSACTION PROCESSING & CONCURRENCY CONTROL BASICS
================================================================================

Hey! This is YOUR exam-ready guide. Everything is explained simply.
Read section by section. Take breaks between â­ symbols if needed!

================================================================================
ğŸ“š PART 1: WHAT IS A TRANSACTION?
================================================================================

ğŸ”µ SIMPLE DEFINITION:
--------------------
A TRANSACTION is a SINGLE UNIT of work that either:
â€¢ COMPLETES FULLY (all changes saved) OR
â€¢ FAILS COMPLETELY (no changes at all)

Think of it like:
â€¢ Withdrawing money from ATM
â€¢ Either you get the money AND your account is debited
â€¢ OR nothing happens at all
â€¢ You can't have money come out but account not debited!

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

ğŸ”µ DATABASE ACCESS OPERATIONS:
------------------------------
There are only TWO basic operations:

1. READ_ITEM(X)
   â€¢ Reads value of data item X from database
   â€¢ Brings it into memory (program variable)
   
2. WRITE_ITEM(X)  
   â€¢ Writes value from program variable X back to database
   â€¢ Updates the database with new value

Every transaction has:
â€¢ READ SET = All items the transaction reads
â€¢ WRITE SET = All items the transaction writes/changes

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

ğŸ”µ TYPES OF DBMS:
-----------------

SINGLE-USER DBMS:
â€¢ Only ONE user can use at a time
â€¢ Example: Your personal computer database
â€¢ No concurrency problems!

MULTIUSER DBMS:
â€¢ MANY users at the same time
â€¢ Example: Airline reservation system, bank system
â€¢ Needs CONCURRENCY CONTROL to avoid problems!

================================================================================
ğŸ“š PART 2: PROCESSING METHODS (HOW TRANSACTIONS RUN)
================================================================================

ğŸ”µ SERIAL PROCESSING:
--------------------
â€¢ Transactions run ONE AFTER ANOTHER
â€¢ T1 completes â†’ Then T2 starts â†’ Then T3 starts
â€¢ Like waiting in a queue - one at a time

PROS: âœ… Always CORRECT results
CONS: âŒ VERY SLOW! Poor throughput!

ğŸ”µ INTERLEAVED PROCESSING:
--------------------------
â€¢ Transactions SWITCH between each other
â€¢ Like multitasking on your computer
â€¢ T1 runs a bit â†’ T2 runs a bit â†’ T1 continues â†’ etc.

Example:
    T1: Read X â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Write X â”€â”€â”€â”€â”€â”€â”€ Read Y
    T2:        â”€â”€â”€â”€ Read Y â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Write Y â”€â”€â”€â”€â”€â”€â”€

WHY INTERLEAVE?
â€¢ Better CPU utilization
â€¢ While T1 waits for I/O, T2 can use CPU
â€¢ Higher THROUGHPUT (more transactions completed per second)

DANGER: Can cause PROBLEMS if not controlled! âš ï¸

ğŸ”µ PARALLEL PROCESSING:
-----------------------
â€¢ Multiple transactions run TRULY SIMULTANEOUSLY
â€¢ Requires multiple CPUs/cores
â€¢ Modern systems use this

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 3: PROBLEMS WITH CONCURRENT EXECUTION (MEMORIZE THESE!)
================================================================================

When multiple transactions run together WITHOUT control, these problems occur:

ğŸ”´ PROBLEM 1: LOST UPDATE PROBLEM
---------------------------------
WHAT HAPPENS:
â€¢ T1 reads X (value = 100)
â€¢ T2 reads X (value = 100)  
â€¢ T1 updates X to 150 (adds 50)
â€¢ T2 updates X to 180 (adds 80)
â€¢ FINAL VALUE = 180

WHAT'S WRONG?
â€¢ T1's update is LOST!
â€¢ Should be 100 + 50 + 80 = 230
â€¢ But we got 180

REAL LIFE EXAMPLE:
â€¢ Two people booking the last seat on a flight
â€¢ Both see 1 seat available
â€¢ Both book it â†’ PROBLEM!

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

ğŸ”´ PROBLEM 2: TEMPORARY UPDATE (DIRTY READ) PROBLEM
---------------------------------------------------
WHAT HAPPENS:
â€¢ T1 updates X from 100 to 150
â€¢ T2 reads X (gets 150) â† This is a DIRTY READ!
â€¢ T1 FAILS and rolls back X to 100
â€¢ T2 used the value 150 which was NEVER COMMITTED!

WHAT'S WRONG?
â€¢ T2 read "dirty" data (uncommitted data)
â€¢ T2's results are based on data that never existed officially!

REAL LIFE EXAMPLE:
â€¢ Someone transfers $500 to you
â€¢ You see $500 in your account (dirty read)
â€¢ The transfer fails/reverses
â€¢ You already spent assuming you had $500!

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

ğŸ”´ PROBLEM 3: INCORRECT SUMMARY PROBLEM
---------------------------------------
WHAT HAPPENS:
â€¢ T1 is calculating SUM of all account balances
â€¢ While T1 is running, T2 transfers money between accounts
â€¢ T1's sum is WRONG because data changed mid-calculation!

REAL LIFE EXAMPLE:
â€¢ Counting total money in a bank
â€¢ While counting, people are transferring money
â€¢ Your count is neither the "before" nor "after" total!

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

ğŸ”´ PROBLEM 4: NON-REPEATABLE READ PROBLEM
-----------------------------------------
WHAT HAPPENS:
â€¢ T1 reads X (value = 100)
â€¢ T2 updates X to 150 and commits
â€¢ T1 reads X again (value = 150)
â€¢ T1 got TWO DIFFERENT VALUES for the same item!

WHAT'S WRONG?
â€¢ Same transaction, same read, different results!
â€¢ T1's logic might break if it expected consistent data

REAL LIFE EXAMPLE:
â€¢ You check your CGPA - it shows 3.1
â€¢ Someone updates a grade
â€¢ You check again in SAME session - it shows 3.2
â€¢ Your report shows different values!

================================================================================
ğŸ“š PART 4: CONFLICT OPERATIONS (VERY IMPORTANT!)
================================================================================

ğŸ”µ WHAT IS A CONFLICT?
----------------------
Two operations CONFLICT if ALL THREE conditions are true:

1. They belong to DIFFERENT transactions (T1 and T2)
2. They access the SAME data item (both access X)
3. At least ONE is a WRITE operation

ğŸ”µ CONFLICT TYPES:
------------------

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Operation 1        â•‘ Operation 2        â•‘ CONFLICT?        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ T1 READ(X)         â•‘ T2 READ(X)         â•‘ âŒ NO            â•‘
â•‘ T1 READ(X)         â•‘ T2 WRITE(X)        â•‘ âœ… YES           â•‘
â•‘ T1 WRITE(X)        â•‘ T2 READ(X)         â•‘ âœ… YES           â•‘
â•‘ T1 WRITE(X)        â•‘ T2 WRITE(X)        â•‘ âœ… YES           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MEMORY TRICK: 
"Read-Read = OK, anything with Write = CONFLICT"

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 5: SCHEDULES (HISTORY)
================================================================================

ğŸ”µ WHAT IS A SCHEDULE?
----------------------
A SCHEDULE (also called HISTORY) is the ORDER in which operations 
from multiple transactions are executed.

Example Schedule with T1 and T2:
    r1(X), r2(X), w1(X), w2(X), c1, c2

This means:
â€¢ T1 reads X
â€¢ T2 reads X  
â€¢ T1 writes X
â€¢ T2 writes X
â€¢ T1 commits
â€¢ T2 commits

ğŸ”µ TYPES OF SCHEDULES:
----------------------

1. SERIAL SCHEDULE:
   â€¢ One transaction completes FULLY before next starts
   â€¢ T1 â†’ T2 â†’ T3 (no mixing)
   â€¢ ALWAYS CORRECT âœ…
   â€¢ Examples:
     - Schedule A: T1 complete, then T2 complete
     - Schedule B: T2 complete, then T1 complete
   
2. NON-SERIAL SCHEDULE (INTERLEAVED):
   â€¢ Operations from different transactions are mixed
   â€¢ May or may not be correct
   â€¢ Need to CHECK if it's SERIALIZABLE

ğŸ”µ HOW MANY SERIAL SCHEDULES?
-----------------------------
For N transactions: N! (factorial) serial schedules

Example: 2 transactions â†’ 2! = 2 serial schedules
â€¢ T1 then T2
â€¢ T2 then T1

Example: 3 transactions â†’ 3! = 6 serial schedules

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 6: SERIALIZABILITY (KEY CONCEPT!)
================================================================================

ğŸ”µ WHAT IS SERIALIZABILITY?
---------------------------
A non-serial schedule is SERIALIZABLE if:
â€¢ Its result is EQUIVALENT to SOME serial schedule
â€¢ It produces the same final database state

WHY CARE?
â€¢ Serial = Correct but slow
â€¢ Serializable = Correct AND fast!

ğŸ”µ CONFLICT SERIALIZABILITY:
----------------------------
A schedule is CONFLICT SERIALIZABLE if:
â€¢ You can swap non-conflicting operations to get a serial schedule
â€¢ OR use the PRECEDENCE GRAPH method (see below)

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 7: PRECEDENCE GRAPH (TEST FOR SERIALIZABILITY)
================================================================================

ğŸ”µ HOW TO BUILD A PRECEDENCE GRAPH:
-----------------------------------

STEP 1: Create a NODE for each transaction
        T1 â†’ (T1)    T2 â†’ (T2)

STEP 2: For each CONFLICT operation, draw an EDGE
        â€¢ From the transaction that did the operation FIRST
        â€¢ To the transaction that did it SECOND

STEP 3: Check for CYCLES
        â€¢ NO CYCLE â†’ Schedule is SERIALIZABLE âœ…
        â€¢ HAS CYCLE â†’ Schedule is NOT SERIALIZABLE âŒ (DEADLOCK!)

ğŸ”µ EXAMPLE:
-----------
Schedule: r1(X), r2(X), w1(X), w2(X)

Conflicts:
â€¢ r2(X) before w1(X) â†’ T2 did it first â†’ Edge: T2 â†’ T1
â€¢ w1(X) before w2(X) â†’ T1 did it first â†’ Edge: T1 â†’ T2

Graph:
    T2 â†’ T1
    T1 â†’ T2
    
This is a CYCLE! â†’ NOT SERIALIZABLE â†’ DEADLOCK!

ğŸ”µ ANOTHER EXAMPLE:
-------------------
Schedule D: r1(X), w1(X), r2(Y), w2(Y), r1(Y), w1(Y)

Check conflicts:
â€¢ w2(Y) then r1(Y): T2 wrote, T1 read â†’ Edge: T2 â†’ T1
â€¢ w2(Y) then w1(Y): T2 wrote, T1 wrote â†’ Edge: T2 â†’ T1

Graph:
    T2 â†’ T1 (only)
    
NO CYCLE! â†’ SERIALIZABLE âœ…
Equivalent to serial schedule: T2 then T1

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 8: ISOLATION LEVELS (SQL STANDARD)
================================================================================

When you start a transaction, you can set an ISOLATION LEVEL.
Higher level = More protection but slower performance.

ğŸ”µ LEVEL 0: READ UNCOMMITTED (Lowest protection)
------------------------------------------------
â€¢ ALLOWS dirty reads
â€¢ Can read data that other transactions haven't committed yet
â€¢ FASTEST but RISKY!
â€¢ Use when: You don't care about reading temporary values

ğŸ”µ LEVEL 1: READ COMMITTED
--------------------------
â€¢ NO dirty reads allowed
â€¢ You only read COMMITTED data
â€¢ Other transaction updates? You see OLD (committed) version
â€¢ CASCADING ROLLBACK never happens

Example:
â€¢ T1 changes X from 10 to 20 (not committed)
â€¢ T2 reads X â†’ Gets 10 (the committed value)
â€¢ T1 commits â†’ Now X = 20
â€¢ T2 reads X again â†’ Gets 20

ğŸ”µ LEVEL 2: REPEATABLE READ
---------------------------
â€¢ NO dirty reads
â€¢ NO non-repeatable reads
â€¢ Once you read X, NO ONE can change X until you're done
â€¢ Your reads are CONSISTENT throughout transaction

Example:
â€¢ T1 reads CGPA â†’ Gets 3.1
â€¢ T2 tries to update CGPA â†’ BLOCKED! Must wait for T1
â€¢ T1 reads CGPA again â†’ Still 3.1 (guaranteed!)
â€¢ T1 commits â†’ T2 can now update

ğŸ”µ LEVEL 3: SERIALIZABLE (Highest protection)
---------------------------------------------
â€¢ ALL problems prevented
â€¢ Transactions behave as if they ran serially
â€¢ SAFEST but SLOWEST

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

ğŸ”µ ISOLATION LEVELS SUMMARY TABLE:
----------------------------------

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Isolation Level      â•‘ Dirty Read  â•‘ Non-Repeatable    â•‘ Phantom     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Read Uncommitted     â•‘ POSSIBLE    â•‘ POSSIBLE          â•‘ POSSIBLE    â•‘
â•‘ Read Committed       â•‘ NOT POSSIBLEâ•‘ POSSIBLE          â•‘ POSSIBLE    â•‘
â•‘ Repeatable Read      â•‘ NOT POSSIBLEâ•‘ NOT POSSIBLE      â•‘ POSSIBLE    â•‘
â•‘ Serializable         â•‘ NOT POSSIBLEâ•‘ NOT POSSIBLE      â•‘ NOT POSSIBLEâ•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•

================================================================================
ğŸ“š PART 9: CASCADING ROLLBACK
================================================================================

ğŸ”µ WHAT IS CASCADING ROLLBACK?
------------------------------
When one transaction fails, OTHER transactions that read its 
dirty data MUST ALSO BE ROLLED BACK.

Chain reaction: T1 fails â†’ T2 fails â†’ T3 fails...

Example:
â€¢ T1 writes X = 20
â€¢ T2 reads X (dirty read - gets 20)
â€¢ T3 reads from T2's result
â€¢ T1 ABORTS!
â€¢ T2 must ABORT (it used T1's dirty data)
â€¢ T3 must ABORT (it used T2's data)

WHY IS THIS BAD?
â€¢ Wastes all the work those transactions did
â€¢ Reduces throughput
â€¢ Can be avoided with proper isolation levels

ğŸ”µ CASCADELESS SCHEDULE:
------------------------
â€¢ NO transaction reads dirty data
â€¢ If T1 fails, no one else is affected
â€¢ Much better for performance!

================================================================================
ğŸ“š PART 10: TRANSACTION STATES (LIFECYCLE)
================================================================================

A transaction goes through these STATES:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ACTIVE  â”‚ â† Transaction is running, doing read/write
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ PARTIALLY COMMITTED â”‚ â† All operations done, waiting for final OK
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
       â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ COMMITTED â”‚    â”‚  FAILED  â”‚ â† Something went wrong
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
       âœ…              â”‚
   PERMANENT           â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚  ABORTED   â”‚ â† Changes rolled back
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      âŒ
                  UNDONE

ğŸ”µ KEY POINTS:
--------------
â€¢ COMMITTED = Changes are PERMANENT (can't be undone)
â€¢ ABORTED = All changes are UNDONE (as if never happened)
â€¢ Transaction is NOT committed until ALL operations succeed

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 11: DEADLOCK
================================================================================

ğŸ”µ WHAT IS DEADLOCK?
--------------------
Two or more transactions are WAITING FOR EACH OTHER forever!

Example:
â€¢ T1 holds lock on X, wants Y
â€¢ T2 holds lock on Y, wants X
â€¢ T1 waits for T2 to release Y
â€¢ T2 waits for T1 to release X
â€¢ NEITHER CAN PROCEED! â†’ DEADLOCK!

Picture:
    T1 â”€â”€wantsâ”€â”€â†’ Y (held by T2)
    â†‘                    â”‚
    â”‚                    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†â”˜
    X (held by T1) â†â”€wantsâ”€ T2

ğŸ”µ HANDLING DEADLOCKS:
----------------------

METHOD 1: DEADLOCK DETECTION
â€¢ Let deadlock happen
â€¢ Build a WAIT-FOR GRAPH
â€¢ If CYCLE detected â†’ Deadlock exists!
â€¢ Pick a VICTIM and abort it
â€¢ Other transactions continue

METHOD 2: DEADLOCK AVOIDANCE (Wait-Die, Wound-Wait)
â€¢ Use TIMESTAMPS (when transaction started)
â€¢ OLDER transaction = smaller timestamp = started earlier
â€¢ YOUNGER transaction = larger timestamp = started later

WAIT-DIE SCHEME:
â€¢ If OLDER wants resource held by YOUNGER â†’ OLDER WAITS
â€¢ If YOUNGER wants resource held by OLDER â†’ YOUNGER DIES (aborts)

WOUND-WAIT SCHEME:
â€¢ If OLDER wants resource held by YOUNGER â†’ OLDER WOUNDS (aborts) YOUNGER
â€¢ If YOUNGER wants resource held by OLDER â†’ YOUNGER WAITS

METHOD 3: DEADLOCK PREVENTION
â€¢ Lock ALL resources at the START
â€¢ If you can't get all, don't start
â€¢ No deadlock possible, but poor throughput

â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­â­

================================================================================
ğŸ“š PART 12: TIMESTAMPS
================================================================================

ğŸ”µ WHAT IS A TIMESTAMP?
-----------------------
â€¢ A UNIQUE identifier assigned to each transaction
â€¢ Usually based on system clock or counter
â€¢ Smaller timestamp = OLDER (started earlier)
â€¢ Larger timestamp = YOUNGER (started later)

Example:
â€¢ T1 starts at time 100 â†’ TS(T1) = 100
â€¢ T2 starts at time 150 â†’ TS(T2) = 150
â€¢ T1 is OLDER than T2

ğŸ”µ TOTAL ORDERING:
------------------
â€¢ No two transactions have the same timestamp
â€¢ For any two transactions, one is older, one is younger
â€¢ This helps resolve conflicts!

================================================================================
ğŸ¯ EXAM TIPS FOR LECTURE 2
================================================================================

1. MEMORIZE the 4 problems: Lost Update, Dirty Read, Incorrect Summary, 
   Non-Repeatable Read

2. KNOW how to draw Precedence Graph:
   â€¢ Node for each transaction
   â€¢ Edge for each conflict (from first to second)
   â€¢ Cycle = Not Serializable

3. UNDERSTAND isolation levels and what each prevents:
   â€¢ Read Uncommitted â†’ Allows everything
   â€¢ Read Committed â†’ Prevents dirty reads
   â€¢ Repeatable Read â†’ + Prevents non-repeatable reads
   â€¢ Serializable â†’ Prevents all

4. KNOW conflict rules:
   â€¢ Read-Read = NO conflict
   â€¢ Anything with Write = CONFLICT

5. UNDERSTAND deadlock:
   â€¢ Cycle in waiting
   â€¢ Wait-Die: Older waits, Younger dies
   â€¢ Wound-Wait: Older wounds, Younger waits

================================================================================
âœ… QUICK MEMORY TRICKS
================================================================================

"SERIAL = SAFE BUT SLOW"
"SERIALIZABLE = SAFE AND FAST"

"CYCLE IN GRAPH = DEADLOCK = NOT SERIALIZABLE"

"DIRTY READ = Reading someone's unfinished work"

"READ-READ OK, WRITE CAUSES PROBLEMS"

"OLDER TRANSACTION = SMALLER TIMESTAMP"

================================================================================
                    ğŸ’ª YOU GOT THIS! GOOD LUCK! ğŸ’ª
================================================================================
